open Polaris
open Polaris.Syntax
open Polaris.Eval
open Polaris.Driver

let usage_message =
  "Usage: polaris [options] [file] [program options]\n\
  \    \n\
  \    Options\n\
  \      -i, --interactive         Run in interactive mode (default if no file \
   is specified)\n\
  \      -c <expr>, --eval <expr>  Eval <expr> and print the result\n\
  \      --verbose-names           Disambiguate duplicate names by suffixing \
   each one with a unique identifier\n\n\
  \    Debugging options (these are only useful if you are trying to debug the \
   interpreter)\n\
  \      --print-ast         Print the parsed abstract syntax tree. \n\
  \      --print-renamed     Print the renamed syntax tree.\n\
  \      --print-tokens      Print the tokens generated by the lexer without \
   running the code.\n\
  \      --print-substituted Print substituted unification variables\n\
  \      --print-type-levels Print type levels for unification variables and \
   skolems\n\
  \      --trace <category>  Enable traces for a given category.\n\
  \                          Possible values: "
  ^ String.concat ", " (Trace.get_categories ())

let fail_usage : 'a. string -> 'a =
 fun msg ->
  print_endline (msg ^ "\n\n" ^ usage_message);
  exit 1

let use_colors () = Unix.isatty Unix.stdout

let fatal_error maybe_loc (message : string) =
  (* We might need to disable colors if we are outputting to something other than a tty *)
  let text_style = Errormessage.make_text_style ~enable_color:(use_colors ()) in

  let prefix =
    match maybe_loc with
    | Some loc -> text_style.bold (Loc.pretty_start loc ^ ": ")
    | None -> ""
  in
  let suffix =
    match maybe_loc with
    | None -> ""
    | Some loc ->
        let input_file = In_channel.open_text loc.file in

        let previous_line, line, next_line =
          Errormessage.extract_source_fragment loc input_file text_style `Error
        in
        let line_text = string_of_int loc.start_line in
        let padding = String.make (String.length line_text) ' ' in

        let line_color = text_style.custom ~color:"\x1b[34m" in

        "\n"
        ^ text_style.bold (line_color (padding ^ " ┃ "))
        ^ previous_line ^ "\n"
        ^ text_style.bold (line_color (line_text ^ " ┃ "))
        ^ line ^ "\n"
        ^ text_style.bold (line_color (padding ^ " ┃ "))
        ^ next_line
  in

  print_endline (prefix ^ text_style.error "ERROR" ^ ":\n" ^ message ^ suffix);
  exit 1

let repl_error maybe_loc (message : string) =
  let open Errormessage in
  let text_style = make_text_style ~enable_color:(use_colors ()) in

  let prefix =
    match maybe_loc with
    | Some loc -> text_style.bold (Loc.pretty_start loc ^ ": ")
    | None -> ""
  in
  print_endline (prefix ^ text_style.error "ERROR" ^ ":\n" ^ message)

type run_options = {
  interactive : bool;
  eval : string option;
  print_ast : bool;
  print_renamed : bool;
  print_tokens : bool;
}

let handle_errors text_style print_fun result =
  match result with
  | Ok x -> x
  | Error (Error.EvalError (ArgParseError msg)) ->
      (* We cannot run the script if there was an error parsing arguments *)
      print_endline msg;
      exit 1
  | Error err -> Error.pretty_error text_style print_fun err

let run_repl_with ~fs ~mgr (scope : Rename.RenameScope.t)
    (type_env : Polaris.Types.global_env) (env : eval_env)
    (options : run_options) : unit =
  Sys.catch_break true;
  let driver_options =
    {
      filename =
        "<interactive>"
        (* argv.(0) is "", to signify that this is a repl process.
           This is in line with what python does. *);
      argv = env.argv;
      print_ast = options.print_ast;
      print_renamed = options.print_renamed;
      print_tokens = options.print_tokens;
      scope_registration = Rename.ignored_scope_registration;
    }
  in
  let text_style = Errormessage.make_text_style ~enable_color:(use_colors ()) in

  let env, scope, type_env, continue =
    match options.eval with
    | Some expr ->
        let result, env, scope, type_env =
          handle_errors text_style fatal_error
            (Driver.run_env ~fs ~mgr driver_options
               (Sedlexing.Utf8.from_string expr)
               env scope ?check_or_infer_top_level:(Some `Infer) type_env)
        in

        begin
          match result with
          | v when isUnitV v -> ()
          | _ -> print_endline (Value.pretty result)
        end;
        (env, scope, type_env, options.interactive)
    | None -> (env, scope, type_env, true)
  in
  if continue then begin
    print_endline
      "Welcome to Polaris! Press Ctrl+D or type \"exit(0)\" to exit.";

    let open Errormessage in
    let prompt = text_style.custom ~color:"\x1b[31m\x1b[38;5;160m" "λ> " in
    let rec go : 'a. eval_env -> Rename.RenameScope.t -> Types.global_env -> 'a
        =
     fun env scope type_env ->
      try
        match Bestline.bestline prompt with
        | None -> exit 0
        | Some input ->
            let _ = Bestline.history_add input in
            let result, new_env, new_scope, new_type_env =
              handle_errors text_style
                (fun mloc msg ->
                  repl_error mloc msg;
                  go env scope type_env)
                (Driver.run_env ~fs ~mgr driver_options
                   (Sedlexing.Utf8.from_string input)
                   env scope ?check_or_infer_top_level:(Some `Infer) type_env)
            in

            begin
              match result with
              | v when isUnitV v -> ()
              | _ -> print_endline (" - " ^ Value.pretty result)
            end;
            go new_env new_scope new_type_env
      with
      | Sys.Break ->
          print_newline ();
          go env scope type_env
    in
    go env scope type_env
  end

let run_file ~fs ~mgr (options : run_options) (filepath : string)
    (args : string list) =
  if Option.is_some options.eval then
    fail_usage "The flags '-c' and '--eval' are invalid when executing a file";

  let text_style = Errormessage.make_text_style ~enable_color:(use_colors ()) in

  let driver_options =
    {
      filename = filepath;
      argv = filepath :: args;
      print_ast = options.print_ast;
      print_renamed = options.print_renamed;
      print_tokens = options.print_tokens;
      scope_registration = Driver.ignored_scope_registration;
    }
  in

  let _, env, scope, type_env =
    handle_errors text_style fatal_error
      (Driver.run_env ~fs ~mgr driver_options
         (Sedlexing.Utf8.from_channel (open_in filepath))
         (Eval.make_eval_env driver_options.argv)
         Rename.RenameScope.empty Types.empty_env)
  in
  if options.interactive then run_repl_with ~fs ~mgr scope type_env env options

let run_repl options =
  let argv = [ "" ] in
  run_repl_with Rename.RenameScope.empty Types.empty_env
    (Eval.make_eval_env argv) options

let parse_args () : run_options * string list =
  let default_options : run_options =
    {
      interactive = false;
      eval = None;
      print_ast = false;
      print_renamed = false;
      print_tokens = false;
    }
  in
  let rec go options = function
    | "--help" :: args ->
        print_endline usage_message;
        exit 0
    | ("-i" | "--interactive") :: args ->
        go { options with interactive = true } args
    | [ (("-c" | "--eval") as f) ] ->
        fail_usage ("Missing required argument for flag '" ^ f ^ "'")
    | ("-c" | "--eval") :: expr :: args ->
        go { options with eval = Some expr } args
    | "--verbose-names" :: args ->
        Config.set_verbose_names true;
        go options args
    | "--print-ast" :: args -> go { options with print_ast = true } args
    | "--print-renamed" :: args -> go { options with print_renamed = true } args
    | "--print-tokens" :: args -> go { options with print_tokens = true } args
    | "--trace" :: category :: args ->
        if Trace.try_set_enabled category true then go options args
        else
          fail_usage
            ("Invalid trace category '" ^ category ^ "'. Possible values: "
            ^ String.concat ", " (Trace.get_categories ()))
    | "--print-substituted" :: args ->
        Config.set_print_subst_unif_vars true;
        go options args
    | "--print-type-levels" :: args ->
        Config.set_print_levels true;
        go options args
    | option :: args when String.starts_with ~prefix:"-" option ->
        fail_usage ("Invalid option: '" ^ option ^ "'.")
    | args -> (options, args)
  in
  go default_options (List.tl (Array.to_list Sys.argv))

let () =
  Eio_main.run
    begin
      fun env ->
        let options, args = parse_args () in

        let fs = Eio.Stdenv.fs env in
        let mgr = (Eio.Stdenv.process_mgr env :> Eio.Process.mgr) in

        match args with
        | [] -> run_repl ~fs ~mgr options
        | filepath :: args -> ignore (run_file ~fs ~mgr options filepath args)
    end
